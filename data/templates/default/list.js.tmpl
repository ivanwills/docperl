[% PROCESS strings.tmpl -%]
[% UNLESS history_size %][% history_size = 10 %][% END -%]
/** @file    list.js
 *  @brief   Javascript for displaying/creating the module lists
 *  @author  Ivan Wills
 *  @version 0.4
 *  @created 2006-06-01
 *  @todo    Add AJAX stuff for file content searching
 *  @bug
 *
 *  This file contains the javascript for controlling the module list in DocPerl.
 *
 */

/**
 *  @param counter: The counter to increment
 *  @param amount:  The amount to increment the counter by
 *  @todo
 *  @bug
 *
 *  Increments the counter by amount (which could be negative)
 */
function add_count( counter, amount ) {
	var counter_span = document.getElementById( counter + '_count' );
	var counter_value = counter_span.firstChild.nodeValue;
	counter_value -= -amount;
	counter_span.removeChild( counter_span.firstChild );
	counter_span.appendChild( document.createTextNode( counter_value ) );
}

/**
 *  @param counter: The counter to reset
 *  @todo
 *  @bug
 *
 *  Resets a counter to zero
 */
function reset_count( counter ) {
	var counter_span = document.getElementById( counter + '_count' );

	counter_span.removeChild( counter_span.firstChild );
	counter_span.appendChild( document.createTextNode( '0' ) );
}

/**
 *  @param tree:    The module tree to count
 *  @param counter: The counter associated with the tree
 *  @todo
 *  @bug
 *
 *  Counts the modules in a tree
 */
function count_tree( tree, counter ) {
	var count = 0;
	for ( var module in tree ) {
		if ( module != '*' ) {
			var data = tree[module];
			var tt   = [];
			for ( var t in data )
				tt.push(t);
			if ( data && tt.length )
				count += count_tree( data, counter );
		}
		else if ( tree[module].length > 0 )
			count++;
	}
	//add_count( counter, count );
	return count;
}

/**
 *  @param  files:
 *  @param  container_id:
 *  @param  path:         The path of the tree
 *  @param  counter:      The counter associated with this tree.
 *  @return :
 *  @todo
 *  @bug
 *
 *  Creates a <ul> tree of modules
 */
var tree_holder = [];
function create_tree ( files, container_id, path, counter ) {
	// need to stick each module into a container
	var container= document.getElementById(container_id);
	var ul       = document.createElement('ul');
	ul.className = 'mod_list';
	ul.id        = 'ul__'+path;
	level++;

	if ( !counter )
		counter = path;
	else
		ul.style.display = 'none';
	if (!files)
		files = tree_holder[path];

	var files_sort = [];
	for ( var module in files ) {
		files_sort.push(module);
	}
	files_sort.sort( function (a,b) {
		return a.toLowerCase() == b.toLowerCase() ? 0 : ( a.toLowerCase() > b.toLowerCase() ? 1 : -1 );
	});

	for ( var module in files_sort ) {
		module = files_sort[module];
		if ( module != '*' ) {
			var li   = document.createElement('li');
			li.id    = 'li__' + path + '__' + module;
			var data = files[module];
			var num  = 0;
			var label;

			// should this just be 'num = data.size;' ?
			for ( var sub in data ) {
				num++;
			}

			// the javascript contains only one element if there are no sub directories
			li.appendChild( create_plus( num >= 2 ? path + '__' + module : null ) );

			data = files[module]['*'];
			if ( data && data.length ) {
				label = create_module( path + '__' + module, module );
			}
			else {
				label = document.createTextNode( module );
			}

			//
			li.appendChild( label );
			tree_holder[path + '__' + module] = files[module];
			ul.appendChild( li );
		}
	}

	container.appendChild( ul );
	return ul;
}

/**
 *  @param  path:   The full module path
 *  @param  module: The module name.
 *  @return <a>:    The anchor tag linking to the module information
 *  @todo
 *  @bug
 *
 *  Creates the module link
 */
function create_module(path, module) {
	var display = path_to_module(path);
	var label   = document.createElement('a');
	label.href  = '?page=pod&module=' + path;
	label.title = display;
	label.setAttribute( 'onclick', 'javascript: click_module("' + path + '");' );
	label.setAttribute( 'target', '[% IF !sidebar %]main[% ELSE %]_content[% END %]' );
	label.appendChild( document.createTextNode( module ) );

	return label;
}

/**
 *  @param  path:      The path to expand to (if no path supplied then a place
 *                     holder element is created).
 *  @return <a>|<div>: Javascript linking anchor tag if there is a path or a
 *                     place holder division other wise.
 *  @todo
 *  @bug
 *
 *  Creates the expansion/collapse element for the lists if there are sub
 *  modules and a place holder element if there are no sub modules.
 */
function create_plus(path) {
	var plus;
	// the javascript contains only one element if there are no sub directories
	if ( path ) {
		plus               = document.createElement('a');
		plus.id            = 'plus__' + path;
		plus.href          = 'javascript: list_toggle("' + path + '")';
		plus.title         = 'Show';
		plus.className     = 'mod_expand';
		plus.style.cssText = 'text-decoration: none';
		plus.appendChild( document.createTextNode( '+' ) );
	}
	else {
		plus               = document.createElement('div');
		plus.className     = 'mod_expand';
		plus.style.cssText = 'border-width: 0px;';
		plus.appendChild( document.createTextNode( '.' ) );
	}

	return plus;
}

/**
 *  @param path: The path that the user clicked on.
 *  @todo
 *  @bug
 *
 *  Event called when the user clicks on a module name. Adds the path to the
 *  recent modules list.
 */
function click_module( path ) {
	var name = 'DocPerl_recent';
	if ( exists_cookie( name ) ) {
		var list    = get_cookie( name );
		var modules = list.split(':');
		for ( var module in modules ) {
			if ( modules[module] == path )
				return;
		}
		list += ':' + path;
		modules.push(path);
		if ( modules.length >= [% history_size %] ) {
			var recent = document.getElementById('ul_recent');
			recent.removeChild( recent.firstChild );
			add_count( 'recent', -1 );
			modules.splice( 0,  modules.length - [% history_size %] );
		}
		set_cookie( name, modules.join(':') );
	}
	else {
		set_cookie( name, path );
	}
	display_recent(path);
}

/**
 *  @param path: The path to add to the recent list
 *  @todo
 *  @bug
 *
 *  Adds a path to the recent module list.
 */
function display_recent(path) {
	var path_parts = path.split('__');
	var recent_doc = document.getElementById('recent_doc');
	var recent_ul  = document.getElementById('ul_recent');
	var name       = path_to_module(path);
	recent_doc.style.cssText = '';
	recent_doc.style.display = 'block';

	var li = document.createElement('li');
	li.appendChild( create_plus() );
	li.appendChild( create_module( path, name ) );

	recent_ul.appendChild( li );
	add_count( 'recent', 1 );
}

/**
 *  @param force: A forces the search for module names less than 4 characters long
 *  @todo
 *  @bug
 *
 *  Searches the all modules names to find those that match the search term
 */
function search(force) {
	var term = document.getElementById('search').value;

	if ( !force && term.length < 4 )
		return;

	if (document.getElementById('type_names').checked)
		search_names(term);
	else
		document.getElementById('names_doc').style.display = 'none';

	if (document.getElementById('type_pod').checked)
		search_ajax({ section: 'pod', area: 'text', terms: term});
	else
		document.getElementById('pod_doc').style.display = 'none';

	if (document.getElementById('type_functions').checked)
		search_ajax({ section: 'functions', area: 'function', terms: term });
	else
		document.getElementById('functions_doc').style.display = 'none';

	if (document.getElementById('type_cpan').checked)
		search_cpan({ section: 'cpan', area: 'function', terms: term });
}

function search_cpan(args) {
	var main = window.parent.main;
	var mode = document.getElementById('mode');
	mode = mode.options[mode.selectedIndex].value;
	main.location = 'http://search.cpan.org/search?mode=' + mode + '&query=' + args.terms;
}

function search_ajax(args) {
	var area_doc = document.getElementById(args.section + '_doc');
	var section  = document.getElementById(args.section);
	var url      = 'search.cgi?type=jason&terms=' + args.terms + '&area=' + args.area;
	var ul       = document.createElement('ul');

	while (section.firstChild)
		section.removeChild(section.firstChild);

	ul.id = 'ul__names';
	section.appendChild(ul);
	reset_count(args.section);

	HTTP.get_jason(
		url,
		function(result) {
			//alert(result + '\n' + args.section);
			area_doc.style.display = 'block';
			add_count( args.section, result.count );

			for ( var name in result.results ) {
				var li     = document.createElement('li');
				var ul_sub = document.createElement('ul');
				var path   = args.section + '__' + name;
				li.id      = 'li__' + path;
				ul_sub.id  = 'ul__' + path;
				li.appendChild( create_plus(path) );
				li.appendChild( document.createTextNode(name) );

				for ( var item in result.results[name] ) {
					var li_sub = document.createElement('li');
					var found_item = result.results[name][item];
					found_item = found_item.replace( /::/g, '__' );

					li_sub.appendChild( create_plus() );
					li_sub.appendChild( create_module( path + '__' + found_item, result.results[name][item] ) );
					ul_sub.appendChild(li_sub);
				}

				li.appendChild(ul_sub);
				ul.appendChild(li);
			}
		}
	);
}

function search_names(term) {
	var names_doc = document.getElementById('names_doc');
	if ( !term ) {
		names_doc.style.cssText = 'display:none';
		return;
	}

	var terms = term.split(/\s+/);
	var names = document.getElementById('names');
	var ul    = document.createElement('ul');
	names_doc.style.cssText = '';

	while (names.firstChild)
		names.removeChild(names.firstChild);

	ul.id = 'ul__names';
	names.appendChild(ul);
	reset_count('names');

	for ( var i in terms ) {
		var cur_term = terms[i];

		var list = show_found( [perl.POD], cur_term, 'perl', 'POD' );
		if ( list )
			ul.appendChild( list );
		list = show_found( local, cur_term, 'local', 'Local' );
		if ( list )
			ul.appendChild( list );
		list = show_found( inc, cur_term, 'inc', 'Installed' );
		if ( list )
			ul.appendChild( list );
	}
}

/**
 *  @param  list: This is the list to search
 *  @param  term: The search tearm
 *  @param  base: The display list id base
 *  @param  name: The display name for the list of found modules
 *  @return <li>: A list item containg a list of all found items
 *  @todo
 *  @bug
 *
 *  Creates list items for found modules
 */
function show_found( list, term, base, name ) {
	var count  = 0;
	var li     = document.createElement('li');
	var ul_sub = document.createElement('ul');
	var path   = 'names__' + base;
	li.id      = 'li__' + path;
	ul_sub.id  = 'ul__' + path;
	li.appendChild( create_plus(path) );
	li.appendChild( document.createTextNode(name) );

	for ( var i in list ) {
		var item  = list[i];
		var found = find_in( item, term );

		if ( found.length ) {
			count += found.length;

			for ( var item in found ) {
				var li_sub = document.createElement('li');
				var found_item = found[item];
				found_item = found_item.replace( /::/g, '__' );

				li_sub.appendChild( create_plus() );
				li_sub.appendChild( create_module( path + '__' + found_item, found[item] ) );
				ul_sub.appendChild(li_sub);
			}
		}
	}

	if ( !count )
		return null;

	add_count( 'names', count );
	li.appendChild(ul_sub);

	return li;
}

/**
 *  @param  list:  The list to search through
 *  @param  term:  The search term to compare with
 *  @param  name:  The name of the module that represents list
 *  @return Array: Array of found modules
 *  @todo
 *  @bug
 *
 *  Recurses through the list trying to find modules that match term
 */
function find_in( list, term, name ) {
	var next  = name ? name + '::' : '';
	var found = [];
	var regex = new RegExp( term, 'i' );

	for ( var item in list ) {
		var module = next + item;

		// Check if the node is actually a module and if it matches the re
		if ( list[item]['*'] && list[item]['*'].length && module.match( regex ) ) {
			found.push( module );
		}

		// itterate to sub modules
		if ( item != '*' ) {
			var matches = find_in( list[item], term, module );
			for ( var i in matches )
				found.push( matches[i] );
		}
	}
	return found;
}

/**
 *  @param id: The id of the list to toggle
 *  @todo
 *  @bug
 *
 *  Toggles open/close the list identified by id
 */
function list_toggle( id ) {
	var ul = document.getElementById( 'ul__' + id );
	if (!ul) {
		ul = create_tree( null, 'li__'+id, id, 'inc');
	}
	var link = document.getElementById( 'plus__' + id );
	// check the status of the list
	if ( ul.style && ul.style.display == 'block' ) {
		// list is open so close
		ul.style.display = 'none';
		link.removeChild( link.firstChild );
		link.appendChild( document.createTextNode('+') );
		link.title = '[% str_list_show %]';
	}
	else {
		// list is closed so open
		ul.style.display = 'block';
		link.removeChild( link.firstChild );
		link.appendChild( document.createTextNode('-') );
		link.title = '[% str_list_hide %]';
	}
}

/**
 *  @param section: The section to toggle open/closed
 *  @todo
 *  @bug
 *
 *  Toggles a whole section open/closed.
 */
function section_toggle( section ) {
	var sect = document.getElementById( section );
	var head = document.getElementById( section + '_head' );
	var link = document.getElementById( 'plus__' + section );
	// check the status of the list
	if ( sect.style && sect.style.display ) {
		// list is closed so open
		sect.style.display = '';
		head.style.marginBottom = '';
		link.removeChild( link.firstChild );
		link.appendChild( document.createTextNode('-') );
		link.title = '[% str_section_hide %]';
		clear_cookie( section );
	}
	else {
		// list is open so close
		sect.style.display = 'none';
		head.style.marginBottom = '1px';
		link.removeChild( link.firstChild );
		link.appendChild( document.createTextNode('+') );
		link.title = '[% str_section_hide %]';
		set_cookie( section, 'hide' );
	}
}

/**
 *  @param  path:   The path to convert to a module name
 *  @return string: The propper module name
 *  @todo
 *  @bug
 *
 *  Converts a path (which is in the form of {section}__{group}__module) into
 *  a standard module name.
 */
function path_to_module(path) {
	var module = path.replace(/__/g, '::');
	return module.replace( /^(?:[^:]+)::(?:[^:]+)::/, '' );
}

/***** CURRENT LINK *****/

/**
 *  @todo implementation
 *  @bug
 *
 *  Sets the current link to a link that the user can click on to see the
 *  page in its current state.
 */

function update_current_link() {
	var link = document.getElementById('current-link');
	var url  = window.parent.main.location.href;

	// Alter the url to load the frames page
	url = url.replace( /page=\w+&?/, '' );

	// add the url to the link
	link.href = url;

	// make sure if the link is clicked that it replaces the current page
	link.target = '_TOP';
}

/*************************\
 *                       *
 *  UTILITIE  FUNCTIONS  *
 *                       *
\*************************/

/***** COOKIES *****/

/**
 *  @param  name:   The name of the cookie wanted
 *  @return string: The value of the cokkie
 *  @todo
 *  @bug
 *
 *  Gets the value of a cookie called name
 */
function get_cookie(name) {
	var result          = null;
	var my_cookie       = ' ' + document.cookie + '; ';
	var search_name     = ' ' + name + '=';
	var start_of_cookie = my_cookie.indexOf(search_name);
	var end_of_cookie;

	if (start_of_cookie != -1) {
		start_of_cookie += search_name.length;
		// skip past cookie name
		end_of_cookie = my_cookie.indexOf(';',start_of_cookie);
		result = unescape(my_cookie.substring(start_of_cookie, end_of_cookie));
	}

	return result
}

/**
 *  @param name:    The name of the cookie to set
 *  @param value:   The value the should have
 *  @param expires: The time that the cookie expires (Date object)
 *  @param path:    The path of the cookie
 *  @param domain:  The domain of the cookie
 *  @param secure:  Flags that the cookie should be secure
 *  @todo
 *  @bug
 *
 *  Sets a cookie with the supplied parameters
 */
function set_cookie(name, value, expires, path, domain, secure) {
	var expiry_string = expires == null ? '' : ('; expires=' + expires.toGMTString());
	var path_string   = path    == null ? '' : ('; path=' + path);
	var domain_string = domain  == null ? '' : ('; domain=' + domain);
	var secure_string = secure  == true ? '; secure' : '';
	var new_cookie    = name + '=' + escape(value) + expiry_string + path_string + domain_string + secure_string;
	document.cookie   = new_cookie;
}

/**
 *  @param name:   The cookie to delete
 *  @param path:   The path of the cookie
 *  @param domain: The domaing of the cookie
 *  @param secure: Flags if the cookie should be secure
 *  @todo
 *  @bug
 *
 *  Clears/deletes a cookie from the system.
 */
function clear_cookie(name, path, domain, secure) {
	var three_days  = 3 * 24 * 60 * 60 * 1000;
	var expiry_date = new Date();
	expiry_date.setTime(expiry_date.getTime() - three_days);
	set_cookie(name, 'ImOutOfHere', expiry_date, path, domain, secure);
}

/**
 *  @param  cookie: The cookie to check for existance
 *  @return bool:   True if the cookie exists false other wise
 *  @todo
 *  @bug
 *
 *  Determines the existance of a cookie
 */
function exists_cookie(cookie) {
	return (get_cookie(cookie) == null) ? false : true;
}

/**
 *  @param  name: The cookie to count
 *  @return int:  The number of cookies with the name name
 *  @todo
 *  @bug
 *
 *  Counts the number of cookies with the name 'name' (ie path, domain, etc are different)
 */
function get_cookie_count(name) {
	var result          = 0;
	var my_cookie       = ' ' + document.cookie + ';';
	var search_name     = ' ' + name + '=';
	var name_length     = search_name.length;
	var start_of_cookie = my_cookie.indexOf(search_name);

	while (start_of_cookie != -1) {
		result += 1;
		start_of_cookie = my_cookie.indexOf(search_name, start_of_cookie + name_length);
	}
	return result;
}

/**
 *  @param  name:          The name of the cookie
 *  @param  cookie_number: The order of the cookie to get
 *  @return string:        The value of the cookie
 *  @todo
 *  @bug
 *
 *  For cookies with many entries this gets the one numberd cookie_number.
 */
function get_cookie_number(name, cookie_number) {
	var result = null;
	if (cookie_number >= 1) {
		var cntr            = 0;
		var my_cookie       = ' ' + document.cookie + ';';
		var search_name     = ' ' + name + '=';
		var name_length     = search_name.length;
		var start_of_cookie = my_cookie.indexOf(search_name);

		for (cntr = 1; cntr < cookie_number; cntr++) {
			start_of_cookie = my_cookie.indexOf(search_name, start_of_cookie + name_length);
		}

		if (start_of_cookie != 1) {
			start_of_cookie  += name_length; // skip past cookie name
			var end_of_cookie = my_cookie.indexOf(';', start_of_cookie);
			result = unescape(my_cookie.substring(start_of_cookie, end_of_cookie));
		}
	}
	return result;
}


// AJAX stuff
// Code from Javascript the definitave guide
var HTTP = {};
HTTP._factories = [
	function() { return new XMLHttpRequest(); },
	function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
	function() { return new ActiveXObject("Microsoft.XMLHTTP"); }
];

HTTP.newRequest = function() {
	if ( HTTP._factory != null ) return HTTP._factory();

	for ( var i = 0; i < HTTP._factories.length; i++ ) {
		try {
			var factory = HTTP._factories[i];
			var request = factory();
			if ( request != null ) {
				HTTP._factory = factory;
				return request;
			}
		}
		catch (e) {
			continue;
		}
	}

	HTTP._factory = function() { throw new Error("XMLHttpRequest not supported") };
	HTTP._factory();
	return false;
};

HTTP.get_jason = function(url, callback) {
	var request = HTTP.newRequest();
	request.onreadystatechange = function() {
		if (request.readyState == 4 && request.status == 200) {
			try {
				eval('var response = ' + request.responseText + ';');
				callback(response);
			}
			catch (e) {
				throw new Error('Could not eval jason response: ' + e);
				callback(null);
			}
		}
	};
	request.open('GET', url);
	request.send(null);
};

/***** DEBUG ******/

var debug_div   = null;
var debug_found = false;
function debug(msg) {
	if ( !debug_div && debug_found )
		return;
	if ( !debug_div && !debug_found ) {
		debug_div = document.getElementById('debug');
		debug_found = true;
		debug(msg);
		return;
	}

	var out = document.createElement('div');
	out.appendChild( document.createTextNode(msg) );
	debug_div.appendChild(out);

	return;
}
